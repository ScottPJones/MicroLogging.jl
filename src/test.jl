module LogTest

using MicroLogging
import MicroLogging: parse_level

export @test_logs, @test_deprecated

# Log testing tools

using Base.Test
using Compat
import MicroLogging: BelowMinLevel, Debug, Info, Warn, Error, AboveMaxLevel,
    shouldlog, handle_message, min_enabled_level, catch_exceptions,
    configure_logging

import Base: ismatch

#-------------------------------------------------------------------------------
# Log records
struct LogRecord
    level
    message
    _module
    group
    id
    file
    line
    kwargs
end
LogRecord(args...; kwargs...) = LogRecord(args..., kwargs)

struct Ignored ; end

#-------------------------------------------------------------------------------
# Logger with extra test-related state
mutable struct TestLogger <: AbstractLogger
    logs::Vector{LogRecord}
    min_level::LogLevel
    catch_exceptions::Bool
    shouldlog_args
end

TestLogger(; min_level=Info, catch_exceptions=false) = TestLogger(LogRecord[], min_level, catch_exceptions, nothing)
min_enabled_level(logger::TestLogger) = logger.min_level

function shouldlog(logger::TestLogger, level, _module, group, id)
    logger.shouldlog_args = (level, _module, group, id)
    true
end

function handle_message(logger::TestLogger, level, msg, _module,
                        group, id, file, line; kwargs...)
    push!(logger.logs, LogRecord(level, msg, _module, group, id, file, line, kwargs))
end

# Catch exceptions for the test logger only if specified
catch_exceptions(logger::TestLogger) = logger.catch_exceptions

function configure_logging(logger::TestLogger; min_level=Info)
    logger.min_level = min_level
    logger
end

function collect_test_logs(f; kwargs...)
    logger = TestLogger(; kwargs...)
    with_logger(f, logger)
    logger.logs
end


#-------------------------------------------------------------------------------
# Log testing tools

"""
    @test_logs [log_patterns...] [keywords] expression

Collect a list of log records generated by `expression` using
`collect_test_logs`, and check that they match the sequence `log_patterns`.
The `keywords` provide some simple filtering of log records: the `min_level`
keyword controls the minimum log level which will be collected for the test,
the `match_mode` keyword defines how matching will be performed (the default
`:all` checks that all logs and patterns match pairwise; use `:any` to check
that the pattern matches at least once somewhere in the sequence.)

The most useful log pattern is a simple tuple of the form `(level,message)`.
A different number of tuple elements may be used to match other log metadata,
corresponding to the arguments to passed to `AbstractLogger` via the
`handle_message` function: `(level,message,module,group,id,file,line)`.
Elements which are present will be matched pairwise with the log record fields
using `==` by default, with the special cases that `Symbol`s may be used for
the standard log levels, and `Regex`s in the pattern will match string or
Symbol fields using `ismatch`.

# Examples

Consider a function which logs a warning, and several debug messages:

    function foo(n)
        @info "Doing foo with n=\$n"
        for i=1:n
            @debug "Iteration \$i"
        end
    end

We can test the info message using

    @test_logs (:info,"Doing foo with n=2") foo(2)

If we also wanted to test the debug messages, these need to be enabled with the
`min_level` keyword:

    @test_logs (:info,"Doing foo with n=2") (:debug,"Iteration 1") (:debug,"Iteration 2") min_level=Debug foo(2)

"""
macro test_logs(exs...)
    length(exs) >= 1 || throw(ArgumentError("""`@test_logs` needs at least one arguments.
                               Usage: `@test_logs [msgs...] expr_to_run`"""))
    args = Any[]
    kwargs = Any[]
    for e in exs[1:end-1]
        if e isa Expr && e.head == :(=)
            push!(kwargs, esc(Expr(:kw, e.args...)))
        else
            push!(args, esc(e))
        end
    end
    # TODO: Better error reporting in @test
    ex = quote
        @test ismatch_logs($(args...); $(kwargs...)) do
            $(esc(exs[end]))
        end
    end
    if Compat.macros_have_sourceloc
        # Propagate source code location of @test_logs to @test macro
        ex.args[2].args[2] = __source__
    end
    ex
end

function ismatch_logs(f, patterns...; match_mode::Symbol=:all, kwargs...)
    logs = collect_test_logs(f; kwargs...)
    if match_mode == :all
        length(logs) == length(patterns) &&
            all(ismatch(p,l) for (p,l) in zip(patterns, logs))
    elseif match_mode == :any
        all(any(ismatch(p,l) for l in logs) for p in patterns)
    end
end

logfield_ismatch(a, b) = a == b
logfield_ismatch(r::Regex, b) = ismatch(r, b)
logfield_ismatch(r::Regex, b::Symbol) = ismatch(r, String(b))
logfield_ismatch(a::Symbol, b::LogLevel) = parse_level(a) == b
logfield_ismatch(a::Ignored, b) = true

function ismatch(pattern::Tuple, r::LogRecord)
    stdfields = (r.level, r.message, r._module, r.group, r.id, r.file, r.line)
    all(logfield_ismatch(p,f) for (p,f) in zip(pattern, stdfields[1:length(pattern)]))
end

if MicroLogging.core_in_base

macro test_deprecated(exs...)
    1 <= length(exs) <= 2 || throw(ArgumentError("""`@test_deprecated` expects one or two arguments.
                               Usage: `@test_deprecated [pattern] expr_to_run`"""))
    pattern = length(exs) == 1 ? r"deprecated"i : esc(exs[1])
    expression = esc(exs[end])
    res = quote
        dw = Base.JLOptions().depwarn
        if dw == 2
            # TODO: Remove --depwarn=error if possible and replace with a more
            # flexible mechanism so we don't have to do this.
            @test_throws ErrorException $expression
        elseif dw == 1
            @test_logs (:warn, $pattern, Ignored(), :depwarn) match_mode=:any $expression
        else
            # dw == 0 globally disables depwarns.  Should we set --depwarn=no
            # to log at something higher than BelowMinLevel, so we can continue
            # to test it here?
        end
    end
    if Compat.macros_have_sourceloc
        # Propagate source code location of @test_logs to @test macro
        res.args[4].args[2].args[2].args[2] = __source__
        res.args[4].args[3].args[2].args[2].args[2] = __source__
    end
    res
end

end

end
